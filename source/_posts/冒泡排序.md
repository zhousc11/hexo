---
title: 冒泡排序
tags:
  - 学习日记
  - C
  - 算法
  - 排序
excerpt: |-
  # 初识冒泡排序法
  冒泡排序法是很很基本的一个排序算法了，是一个实现起来相对比较简单的一种算法。
  他的原理大概是逐一扫描相邻的两个数，并进行比较，再进行数的交换从而依次排序的一种算法。
  黄海军老师其实上个星期就已经在上课时讲了这一种算法了，但是我实在是太困...
date: 2023-03-31 11:27:00
categories:
---

\# 初识冒泡排序法 冒泡排序法是很很基本的一个排序算法了，是一个实现起来相对比较简单的一种算法。 他的原理大概是逐一扫描相邻的两个数，并进行比较，再进行数的交换从而依次排序的一种算法。 黄海军老师其实上个星期就已经在上课时讲了这一种算法了，但是我实在是太困...
<!-- more -->
\# 初识冒泡排序法

冒泡排序法是很很基本的一个排序算法了，是一个实现起来相对比较简单的一种算法。

他的原理大概是逐一扫描相邻的两个数，并进行比较，再进行数的交换从而依次排序的一种算法。

黄海军老师其实上个星期就已经在上课时讲了这一种算法了，但是我实在是太困了，一点都没听。（这里真的很对不起黄海军老师）

最近实验室考核题目中有了这一道题目，今天花了几分钟时间也算初识了这一种算法了吧。（逃）

* * *

下面我就以（5、1、2、4、8）这几个数作为待排列数据（从小到大），来简要说明一下冒泡排序法的实现流程吧。

## 第一轮排序

第一轮排序中，通过扫描每一组相邻的两个数，从而进行排序。

详细过程：

> 1.  扫描前两个数5和1，将较大的数排列在后，交换两数位置。
> 2.  扫描第2、3两个数5和4，将较大的数排列在后，同为交换位置
> 3.  扫描第3、4两个数5和2，将较大的数排列在后，同为交换位置
> 4.  以此类推……

这样一来，我们就找出了整个数组里最大的数了，因为已经将所有数据全部扫描一遍了，以后的扫描只需要扫描四个数字就可以了。下面我们就进行第二轮排列。

## 第二轮排列

第二轮排列沿用第一轮排列的方式，依次扫描每一个数据，将第二大的数排列在倒数第二，此处不再赘述。

而此时剩下的数据只有三个了，可以进入第三轮排列了。

## 第三轮排列

第三轮排列同为以上的方法，扫描尚未排列的每两个数，并交换其位置。

排列好后，进入第四轮排列。

## 第四轮排列

由于本来就是1<2，所以此处不需要进行交换了，整个数组就已经被排列好了。

其实严格的来讲，应该还存在第五组排序的

## 第五轮排列

由于只剩下了一个数字，无法进行比较，所以将其直接放入已排序的数列里了。

* * *

这样大概就是冒泡排序法的基本实现过程了吧。在查阅资料的过程中，我了解到冒泡排序法是一种**稳定**的排序法，意思就是说冒泡排序法对于值相等的元素，不会改变其相对位置。因为在做对比的时候，如果相等的话，这种算法会原封不动的保留，不会对元数据造成任何影响。

对于冒泡排序法这个名字，我的理解是这样的：每两个数据之间进行比较，如果遇到了比我大的，就往后（前）冒泡，慢慢的往后（前）冒泡，从而实现排序的功能。

因为我的理解中，这种算法不是很直接的找到最大值和每一个数据的值，然后把这些值放到它本来该处于的位置，而是去一个一个依次扫描排序的，不是那种拿起来放上去的很直接的方式吧哈哈哈哈哈哈哈，我也不知怎么说，大概就是这个意思吧，，，

* * *

## 关于代码实现

别问，问就是我还没想好怎么写😭，这里先从别人那里抄一段，到时候有时间了再回来看能不能看懂吧👀

```cpp
#include <stdio.h>
//交换 a 和 b 的位置的函数
#define N 5
int a[N] = { 5,1,4,2,8 };
void swap(int *a, int *b);
//这是带输出的冒泡排序实现函数，从输出结果可以分析冒泡的具体实现流程
void BubSort_test();
//这是不带输出的冒泡排序实现函数，通过此函数，可直接对数组 a 中元素进行排序
void BubSort_pro();
int main()
{
    BubSort_test();
    return 0;
}
void swap(int *a, int *b) {
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

//这是带输出的冒泡排序实现函数，从输出结果，可以看到冒泡的具体实现流程
void BubSort_test() {
    for (int i = 0; i < N; i++) {
        //对待排序序列进行冒泡排序
        for (int j = 0; j + 1 < N - i; j++) {
            //相邻元素进行比较，当顺序不正确时，交换位置
            if (a[j] > a[j + 1]) {
                swap(&a[j], &a[j + 1]);
            }
        }
        //输出本轮冒泡排序之后的序列
        printf("第%d轮冒泡排序：", i + 1);
        for (int i = 0; i < N; i++) {
            printf("%d ", a[i]);
        }
        printf("\n");
    }
}

//这是不带输出的冒泡排序实现函数，通过此函数，可直接对数组 a 中元素进行排序
void BubSort_pro() {
    for (int i = 0; i < N; i++) {
        //对待排序序列进行冒泡排序
        for (int j = 0; j + 1 < N - i; j++) {
            //相邻元素进行比较，当顺序不正确时，交换位置
            if (a[j] > a[j + 1]) {
                swap(&a[j], &a[j + 1]);
            }
        }
    }
}
```

就这些吧，早点睡觉了